const std = @import("std");
const common = @import("common");
const zigxCompiler = @import("zigxCompiler");

const Writer = common.Writer;

pub fn generate(allocator: std.mem.Allocator, server_dir: []const u8, doc: zigxCompiler.ZigxDocument) !void {
    var path_buf: [512]u8 = undefined;
    const file_path = std.fmt.bufPrint(&path_buf, "{s}/{s}.zig", .{ server_dir, doc.file_name }) catch return error.PathTooLong;

    var out_file = try std.fs.cwd().createFile(file_path, .{});
    defer out_file.close();

    var buf: [16384]u8 = undefined;
    var writer = out_file.writer(&buf);
    const w = &writer.interface;

    try writeHeader(w, doc.file_name);
    try writeServerCode(w, doc.server_code);
    try writeHandler(w, doc);
    try writer.interface.flush();

    _ = allocator;
}

fn writeHeader(w: *Writer, file_name: []const u8) !void {
    try w.print(
        \\// Auto-generated server file for {s}
        \\// DO NOT EDIT - Generated by build/gen_zigx.zig and with the power of friendship!
        \\
        \\
    , .{file_name});

    try w.writeAll(common.server_imports);

    //Might remove all the page title shenanigans later on
    try w.print(
        \\
        \\pub const page_title = "{s}";
        \\
        \\
    , .{file_name});
}

fn writeServerCode(w: *Writer, server_code: []const u8) !void {
    if (server_code.len > 0) {
        try w.writeAll(server_code);
        try w.writeAll("\n\n");
    }
}

fn writeHandler(w: *Writer, doc: zigxCompiler.ZigxDocument) !void {
    const has_expressions = doc.expressions.len > 0;

    // Handler signature
    try w.writeAll("pub fn handler(ctx: *RequestContext) !Response {\n");

    // PageContext creation
    try w.writeAll(common.page_context_creation);
    try w.writeAll("\n\n");

    // Init call logic
    try w.writeAll(common.init_call_logic);
    try w.writeAll("\n");

    if (has_expressions) {
        try writeDynamicResponse(w, doc);
    } else {
        try writeStaticResponse(w, doc);
    }

    try w.writeAll("}\n");
}

fn writeDynamicResponse(w: *Writer, doc: zigxCompiler.ZigxDocument) !void {
    try w.writeAll("    return Response.fmtHtml(ctx.allocator,\n");
    try w.writeAll("        \"<!DOCTYPE html><html><head><title>");
    try w.writeAll(doc.file_name);
    try w.writeAll("</title></head><body>");

    // Write format-escaped HTML content
    try common.writeFormatString(w, doc.html_content);

    // Client WASM reference
    if (doc.client_code.len > 0) {
        try w.print("<script>/* Client code available at /wasm/{s}.wasm */</script>", .{doc.file_name});
    }

    try w.writeAll("</body></html>\",\n");
    try w.writeAll("        .{");

    // Write expression arguments (e.g., .{getTitle(), counter, getName()})
    for (doc.expressions, 0..) |expr, i| {
        if (i > 0) try w.writeAll(", ");
        try w.writeAll(expr);
    }

    try w.writeAll(" },\n");
    try w.writeAll("    );\n");
}

fn writeStaticResponse(w: *Writer, doc: zigxCompiler.ZigxDocument) !void {
    try w.writeAll("    return Response.html(\"<!DOCTYPE html><html><head><title>");
    try w.writeAll(doc.file_name);
    try w.writeAll("</title></head><body>");

    // Write escaped HTML content
    try common.writeEscapedString(w, doc.html_content);

    // Client WASM reference
    if (doc.client_code.len > 0) {
        try w.print("<script>/* Client code available at /wasm/{s}.wasm */</script>", .{doc.file_name});
    }

    try w.writeAll("</body></html>\");\n");
}
