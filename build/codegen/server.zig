const std = @import("std");
const common = @import("common");
const zigxParser = @import("zigxParser");
const zigServerParser = @import("zigServerParser");

const Writer = common.Writer;
const Node = zigxParser.Node;

pub fn generate(allocator: std.mem.Allocator, server_dir: []const u8, doc: zigxParser.ZigxDocument) !void {
    var path_buf: [512]u8 = undefined;
    const file_path = std.fmt.bufPrint(&path_buf, "{s}/{s}.zig", .{ server_dir, doc.file_name }) catch return error.PathTooLong;

    var out_file = try std.fs.cwd().createFile(file_path, .{});
    defer out_file.close();

    var buf: [4096]u8 = undefined;
    var writer = out_file.writer(&buf);
    const w = &writer.interface;

    // Parse the server code to analyze imports
    var parser = zigServerParser.ZigParser.init(doc.server_code);
    var zig_doc = parser.parse(allocator) catch return error.ParseError;
    defer zig_doc.deinit(allocator);

    try writeHeader(w, doc.file_name, &zig_doc);
    try writeServerCode(w, doc.server_code);
    try writeHandler(w, doc);
    try writer.interface.flush();
}

fn writeHeader(w: *Writer, file_name: []const u8, zig_doc: *const zigServerParser.ZigFile) !void {
    try w.print(
        \\// Auto-generated server file for {s}
        \\// DO NOT EDIT - Generated by build/gen_zigx.zig
        \\
        \\
    , .{file_name});

    if (!zig_doc.hasImport("std")) {
        try w.writeAll(common.std_import);
    }

    try w.writeAll(common.server_imports);

    try w.print(
        \\
        \\pub const page_title = "{s}";
        \\
        \\
    , .{file_name});
}

fn writeServerCode(w: *Writer, server_code: []const u8) !void {
    if (server_code.len > 0) {
        try w.writeAll(server_code);
        try w.writeAll("\n\n");
    }
}

fn writeHandler(w: *Writer, doc: zigxParser.ZigxDocument) !void {
    const has_control_flow = hasControlFlow(doc.content);

    if (has_control_flow) {
        try writeWriterBasedHandler(w, doc);
    } else {
        try writeSimpleHandler(w, doc);
    }
}

// Check if content has any control flow nodes (requires writer-based approach)
fn hasControlFlow(nodes: []const Node) bool {
    for (nodes) |node| {
        switch (node) {
            .for_loop, .if_stmt, .while_loop => return true,
            .html, .expression => {},
        }
    }
    return false;
}

// Writer-based handler for templates with control flow
fn writeWriterBasedHandler(w: *Writer, doc: zigxParser.ZigxDocument) !void {
    try w.writeAll("pub fn handler(ctx: *RequestContext) !Response {\n");

    // PageContext creation
    try w.writeAll(common.page_context_creation);
    try w.writeAll("\n\n");

    // Init call logic
    try w.writeAll(common.init_call_logic);
    try w.writeAll("\n\n");

    // Create ArrayList for building HTML
    try w.writeAll(
        \\    var html = std.ArrayList(u8){};
        \\    defer html.deinit(ctx.allocator);
        \\    const writer = html.writer(ctx.allocator);
        \\
        \\    // Write document header
        \\    try writer.writeAll("<!DOCTYPE html><html><head><title>
    );
    try w.writeAll(doc.file_name);
    try w.writeAll(
        \\</title></head><body>");
        \\
        \\
    );

    // Generate code for each node
    for (doc.content) |node| {
        try writeNodeCode(w, node, 1);
    }

    // Write closing tags
    try w.writeAll(
        \\
        \\    // Write document footer
        \\    try writer.writeAll("</body></html>");
        \\
        \\    return Response.html(try html.toOwnedSlice(ctx.allocator));
        \\}
        \\
    );
}

/// Simple handler for templates without control flow (format string approach)
fn writeSimpleHandler(w: *Writer, doc: zigxParser.ZigxDocument) !void {
    try w.writeAll("pub fn handler(ctx: *RequestContext) !Response {\n");

    // PageContext creation
    try w.writeAll(common.page_context_creation);
    try w.writeAll("\n\n");

    // Init call logic
    try w.writeAll(common.init_call_logic);
    try w.writeAll("\n");

    // Collect expressions for format args
    var expr_count: usize = 0;
    for (doc.content) |node| {
        if (node == .expression) expr_count += 1;
    }

    if (expr_count > 0) {
        // Declare variables for each expression
        var idx: usize = 0;
        for (doc.content) |node| {
            if (node == .expression) {
                try w.print("    const __zigx_val_{d} = {s};\n", .{ idx, node.expression });
                idx += 1;
            }
        }

        try w.writeAll("    return Response.fmtHtml(ctx.allocator,\n");
        try w.writeAll("        \"<!DOCTYPE html><html><head><title>");
        try w.writeAll(doc.file_name);
        try w.writeAll("</title></head><body>");

        // Build format string
        for (doc.content) |node| {
            switch (node) {
                .html => |text| try writeEscapedForFormat(w, text),
                .expression => |expr| {
                    // Find the index of this expression
                    var found_idx: usize = 0;
                    var search_idx: usize = 0;
                    for (doc.content) |search_node| {
                        if (search_node == .expression) {
                            if (std.mem.eql(u8, search_node.expression, expr)) {
                                found_idx = search_idx;
                                break;
                            }
                            search_idx += 1;
                        }
                    }
                    try w.writeAll("\" ++ zigxFmtSpec(@TypeOf(__zigx_val_");
                    try w.print("{d}", .{found_idx});
                    try w.writeAll(")) ++ \"");
                },
                else => {},
            }
        }

        try w.writeAll("</body></html>\",\n");
        try w.writeAll("        .{");

        // Reference the declared variables
        idx = 0;
        for (doc.content) |node| {
            if (node == .expression) {
                if (idx > 0) try w.writeAll(", ");
                try w.print("__zigx_val_{d}", .{idx});
                idx += 1;
            }
        }

        try w.writeAll(" },\n");
        try w.writeAll("    );\n");
    } else {
        // Static HTML
        try w.writeAll("    return Response.html(\"<!DOCTYPE html><html><head><title>");
        try w.writeAll(doc.file_name);
        try w.writeAll("</title></head><body>");

        for (doc.content) |node| {
            if (node == .html) {
                try common.writeEscapedString(w, node.html);
            }
        }

        try w.writeAll("</body></html>\");\n");
    }

    try w.writeAll("}\n");
}

/// Generate code for a single AST node
fn writeNodeCode(w: *Writer, node: Node, indent: usize) !void {
    switch (node) {
        .html => |text| {
            if (text.len > 0) {
                try writeIndent(w, indent);
                try w.writeAll("try writer.writeAll(\"");
                try writeEscapedForString(w, text);
                try w.writeAll("\");\n");
            }
        },
        .expression => |expr| {
            try writeIndent(w, indent);
            try w.writeAll("try std.fmt.format(writer, zigxFmtSpec(@TypeOf(");
            try w.writeAll(expr);
            try w.writeAll(")), .{");
            try w.writeAll(expr);
            try w.writeAll("});\n");
        },
        .for_loop => |loop| {
            try writeIndent(w, indent);
            try w.writeAll("for (");
            try w.writeAll(loop.collection);
            try w.writeAll(") |");
            try w.writeAll(loop.capture);
            try w.writeAll("| {\n");

            for (loop.body) |child| {
                try writeNodeCode(w, child, indent + 1);
            }

            try writeIndent(w, indent);
            try w.writeAll("}\n");
        },
        .if_stmt => |stmt| {
            try writeIndent(w, indent);
            try w.writeAll("if (");
            try w.writeAll(stmt.condition);
            try w.writeAll(") {\n");

            for (stmt.then_body) |child| {
                try writeNodeCode(w, child, indent + 1);
            }

            if (stmt.else_body) |else_nodes| {
                try writeIndent(w, indent);
                try w.writeAll("} else {\n");

                for (else_nodes) |child| {
                    try writeNodeCode(w, child, indent + 1);
                }
            }

            try writeIndent(w, indent);
            try w.writeAll("}\n");
        },
        .while_loop => |loop| {
            try writeIndent(w, indent);
            try w.writeAll("while (");
            try w.writeAll(loop.condition);
            try w.writeAll(")");

            if (loop.capture) |cap| {
                try w.writeAll(" |");
                try w.writeAll(cap);
                try w.writeAll("|");
            }

            try w.writeAll(" {\n");

            for (loop.body) |child| {
                try writeNodeCode(w, child, indent + 1);
            }

            try writeIndent(w, indent);
            try w.writeAll("}\n");
        },
    }
}

fn writeIndent(w: *Writer, indent: usize) !void {
    for (0..indent) |_| {
        try w.writeAll("    ");
    }
}

/// Escape string for use inside a Zig string literal
fn writeEscapedForString(w: *Writer, content: []const u8) !void {
    for (content) |c| {
        switch (c) {
            '\n' => try w.writeAll("\\n"),
            '\r' => try w.writeAll("\\r"),
            '\t' => try w.writeAll("\\t"),
            '"' => try w.writeAll("\\\""),
            '\\' => try w.writeAll("\\\\"),
            else => try w.writeByte(c),
        }
    }
}

/// Escape string for use inside a format string
fn writeEscapedForFormat(w: *Writer, content: []const u8) !void {
    for (content) |c| {
        switch (c) {
            '{' => try w.writeAll("{{"),
            '}' => try w.writeAll("}}"),
            '\n' => try w.writeAll("\\n"),
            '\r' => try w.writeAll("\\r"),
            '\t' => try w.writeAll("\\t"),
            '"' => try w.writeAll("\\\""),
            '\\' => try w.writeAll("\\\\"),
            else => try w.writeByte(c),
        }
    }
}
