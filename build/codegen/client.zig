const std = @import("std");
const common = @import("common");
const zigxCompiler = @import("zigxCompiler");

const Writer = common.Writer;

pub fn generate(allocator: std.mem.Allocator, client_dir: []const u8, doc: zigxCompiler.ZigxDocument) !void {
    // Only generate client file if there's client code
    if (doc.client_code.len == 0) return;

    var path_buf: [512]u8 = undefined;
    const file_path = std.fmt.bufPrint(&path_buf, "{s}/{s}.zig", .{ client_dir, doc.file_name }) catch return error.PathTooLong;

    var out_file = try std.fs.cwd().createFile(file_path, .{});
    defer out_file.close();

    var buf: [16384]u8 = undefined;
    var writer = out_file.writer(&buf);
    const w = &writer.interface;

    try writeHeader(w, doc.file_name);
    try writeClientCode(w, doc.client_code);
    try writeWasmEntry(w);
    try writer.interface.flush();

    _ = allocator;
}

fn writeHeader(w: *Writer, file_name: []const u8) !void {
    try w.print(
        \\// Auto-generated client file for {s}
        \\// DO NOT EDIT - Generated by build/gen_zigx.zig
        \\
    , .{file_name});

    try w.writeAll(common.client_imports);

    try w.print(
        \\pub const page_title = "{s}";
        \\
        \\
    , .{file_name});
}

fn writeClientCode(w: *Writer, client_code: []const u8) !void {
    try w.writeAll(client_code);
}

fn writeWasmEntry(w: *Writer) !void {
    try w.writeAll(
        \\
        \\
        \\// WASM entry point
        \\export fn init() void {}
        \\
    );
}
