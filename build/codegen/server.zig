const std = @import("std");
const common = @import("common");
const zigxCompiler = @import("zigxCompiler");

const Writer = common.Writer;

pub fn generate(allocator: std.mem.Allocator, server_dir: []const u8, doc: zigxCompiler.ZigxDocument) !void {
    var path_buf: [512]u8 = undefined;
    const file_path = std.fmt.bufPrint(&path_buf, "{s}/{s}.zig", .{ server_dir, doc.file_name }) catch return error.PathTooLong;

    var out_file = try std.fs.cwd().createFile(file_path, .{});
    defer out_file.close();

    var buf: [16384]u8 = undefined;
    var writer = out_file.writer(&buf);
    const w = &writer.interface;

    try writeHeader(w, doc.file_name);
    try writeServerCode(w, doc.server_code);
    try writeHandler(w, doc);
    try writer.interface.flush();

    _ = allocator;
}

fn writeHeader(w: *Writer, file_name: []const u8) !void {
    try w.print(
        \\// Auto-generated server file for {s}
        \\// DO NOT EDIT - Generated by build/gen_zigx.zig and with the power of friendship!
        \\
        \\
    , .{file_name});

    try w.writeAll(common.server_imports);

    //Might remove all the page title shenanigans later on
    try w.print(
        \\
        \\pub const page_title = "{s}";
        \\
        \\
    , .{file_name});
}

fn writeServerCode(w: *Writer, server_code: []const u8) !void {
    if (server_code.len > 0) {
        try w.writeAll(server_code);
        try w.writeAll("\n\n");
    }
}

fn writeHandler(w: *Writer, doc: zigxCompiler.ZigxDocument) !void {
    const has_expressions = doc.expressions.len > 0;

    // Handler signature
    try w.writeAll("pub fn handler(ctx: *RequestContext) !Response {\n");

    // PageContext creation
    try w.writeAll(common.page_context_creation);
    try w.writeAll("\n\n");

    // Init call logic
    try w.writeAll(common.init_call_logic);
    try w.writeAll("\n");

    if (has_expressions) {
        try writeDynamicResponse(w, doc);
    } else {
        try writeStaticResponse(w, doc);
    }

    try w.writeAll("}\n");
}

fn writeDynamicResponse(w: *Writer, doc: zigxCompiler.ZigxDocument) !void {
    for (doc.expressions, 0..) |expr, i| {
        try w.print("    const " ++ common.placeholders.VAL_PREFIX ++ "{d} = {s};\n", .{ i, expr });
    }

    try w.writeAll("    return Response.fmtHtml(ctx.allocator,\n");
    try w.writeAll("        \"<!DOCTYPE html><html><head><title>");
    try w.writeAll(doc.file_name);
    try w.writeAll("</title></head><body>");

    try writeFormatStringWithComptimeSpecs(w, doc.html_content);

    // Client WASM reference
    if (doc.client_code.len > 0) {
        try w.print("<script>/* Client code available at /wasm/{s}.wasm */</script>", .{doc.file_name});
    }

    try w.writeAll("</body></html>\",\n");
    try w.writeAll("        .{");

    // Reference the declared variables
    for (doc.expressions, 0..) |_, i| {
        if (i > 0) try w.writeAll(", ");
        try w.print(common.placeholders.VAL_PREFIX ++ "{d}", .{i});
    }

    try w.writeAll(" },\n");
    try w.writeAll("    );\n");
}

// Writes the HTML content, replacing placeholders with comptime zigxFmtSpec calls
fn writeFormatStringWithComptimeSpecs(w: *Writer, content: []const u8) !void {
    var i: usize = 0;

    while (i < content.len) {
        // Check for expression placeholder (e.g., __ZIGX_EXPR_0__)
        if (common.placeholders.detectPlaceholder(content, i)) |len| {
            // Extract the index from the placeholder
            const placeholder = content[i .. i + len];
            if (common.placeholders.parseIndex(placeholder)) |idx| {
                // Close current string, add format spec based on type, reopen string
                try w.writeAll("\" ++ zigxFmtSpec(@TypeOf(" ++ common.placeholders.VAL_PREFIX);
                try w.print("{d}", .{idx});
                try w.writeAll(")) ++ \"");
            }
            i += len;
            continue;
        }

        const c = content[i];
        switch (c) {
            '{' => try w.writeAll("{{"),
            '}' => try w.writeAll("}}"),
            '\n' => try w.writeAll("\\n"),
            '\r' => try w.writeAll("\\r"),
            '"' => try w.writeAll("\\\""),
            '\\' => try w.writeAll("\\\\"),
            else => try w.writeByte(c),
        }
        i += 1;
    }
}

fn writeStaticResponse(w: *Writer, doc: zigxCompiler.ZigxDocument) !void {
    try w.writeAll("    return Response.html(\"<!DOCTYPE html><html><head><title>");
    try w.writeAll(doc.file_name);
    try w.writeAll("</title></head><body>");

    // Write escaped HTML content
    try common.writeEscapedString(w, doc.html_content);

    // Client WASM reference
    if (doc.client_code.len > 0) {
        try w.print("<script>/* Client code available at /wasm/{s}.wasm */</script>", .{doc.file_name});
    }

    try w.writeAll("</body></html>\");\n");
}
